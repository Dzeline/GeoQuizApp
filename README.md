SMS Based Boda-Ride Service Application
SMS Based Boda-Ride Service Application is an Android app that enables motorcycle taxi (boda-boda) ride-hailing through SMS messages. It is designed for regions with limited or no internet access, allowing riders and passengers to coordinate rides using basic phone features. The app supports two user roles (Rider and Client) with tailored interfaces for each. By leveraging SMS for communication and approximate location services from cell towers, this application makes ride-hailing accessible even without GPS or mobile data.
Key Features
Role-Based Access: Separate interfaces and functionality for Riders and Users (Passengers). Riders can manage ride requests and availability, while Users can request rides and communicate with riders. Role selection is done at app launch, ensuring each user sees only the features relevant to their role.
SMS Communication for Rides: All ride requests and chat messages are sent via SMS, enabling the service to work offline without internet. Users request rides or send messages to riders through the app, and riders receive these as SMS (and vice versa). An SMS BroadcastReceiver in the app captures incoming messages, so conversations appear in-app as a chat history for convenience.
Location Sharing (Cell-Tower Approximation): The app can determine an approximate location using cell tower signals (coarse phone network location) when GPS or data is unavailable. Users can share their location with a rider via SMS at the tap of a button. This helps the rider get a rough idea of the pickup point. The location is derived offline and sent as coordinates or a short message, without requiring internet connectivity.
Offline Map Viewing: Integrated OSMDroid map support allows users and riders to view maps and location markers offline. The app can display the user's logged locations or approximate area on an OpenStreetMap-based map. Map tiles can be cached for offline use, so riders and clients can visualize locations and routes without needing Google Maps or an online connection.
Local Data Persistence: All SMS chats and location logs are stored locally using a Room database. This means the message history between rider and user is saved on-device, so users can see previous requests or communications even when offline. Location logs (like approximate coordinates from each share) are also saved and can be reviewed or plotted on the offline map later.
Dependency Injection with Hilt: The project uses Dagger Hilt for clean management of dependencies. Hilt is used to provide instances of the Room database, DAOs/repositories, and location managers throughout the app. This makes the codebase more modular, easier to test, and easier to extend (for example, swapping out the location service or SMS handler if needed).
Modern Android Architecture (MVVM): The app is built following the MVVM (Model-View-ViewModel) pattern along with a repository layer. Business logic and data handling are separated from the UI. ViewModels handle operations like sending/receiving SMS (via repositories/utilities) and expose LiveData for the UI to observe. This modular architecture makes the app maintainable and scalable.
Modular Code Structure: The code is organized by feature (chat, ride request, rider functions, map, location history, etc.), making it easier to navigate and understand. Each feature has its own Activity and ViewModel, and logic is further abstracted into helper classes and repositories. This separation of concerns allows independent development and testing of each feature.

Installation Instructions
To set up and run the SMS Based Boda-Ride Service Application on your local machine, follow these steps:
Clone the Repository: Download or clone the repository from GitHub:
bash
Copy
git clone https://github.com/YourUsername/GeoQuizApp.git
(Replace YourUsername with the actual GitHub username if this is a public repo.)
Open in Android Studio: Launch Android Studio and select File > Open. Navigate to the cloned GeoQuizApp project directory and open it. Gradle will sync the project and download required dependencies. Make sure you have a stable internet connection on first build to fetch all libraries.
Configure Dependencies: The project uses Gradle to manage libraries. Key dependencies (already included in the project’s Gradle files) are:
Dagger Hilt for dependency injection (ensure the hilt-android-gradle-plugin is applied and Gradle scripts include classpath "com.google.dagger:hilt-android-gradle-plugin:VERSION" in the buildscript, and implementation "com.google.dagger:hilt-android:VERSION" with annotation processor or kapt for the compiler).
Room Database for local storage (AndroidX Room components are included; no additional setup needed aside from runtime permissions for storage if on older devices).
OSMDroid for offline maps (the OSMDroid library is included as a dependency to provide map views; it doesn’t require an API key but does need permission to access device storage for caching map tiles).
AndroidX and Jetpack Components: The app uses AndroidX libraries like RecyclerView, LiveData, ViewModel, and Material Components. These are included via Gradle. Ensure you use the latest Android SDK (compile/target SDK 31 or above as per the project settings).
Normally, you do not need to manually install anything apart from Android Studio; Gradle will handle the above libraries. Just verify in the project’s build.gradle files that the dependencies are present (they should be pre-configured in this repository).
Build the Project: Once the project is open and dependencies are resolved, click on Build > Make Project (or the ▶️ Run button). This will compile the app. You should see no errors if all setup is correct.
Run on Device/Emulator: Connect an Android device or start an emulator. Important: To fully test SMS functionality, it’s recommended to use either two physical devices (one as a user, one as a rider) or two emulators that can send SMS to each other. The app will request SMS permissions and location permissions on startup:
Grant SMS send/receive permissions so the app can send messages and listen for incoming ones.
Grant Location permission (specifically coarse location) so the app can fetch cell-based location. If available, also grant fine location for better accuracy (though the app primarily uses cell info for offline mode).
Select the desired module (app) and run it. The app should install on the device/emulator. You will be presented with the role selection screen on first launch.
OSMDroid Offline Map Setup (Optional): If you plan to use the map entirely offline, you may want to pre-download or cache OpenStreetMap tiles for your region. By default, OSMDroid will cache map tiles on the device as you view them (requiring an initial internet connection to get those tiles). For demonstration in a fully offline scenario, you might drive around the map area while online to save tiles, or integrate an offline tile source. This is optional; the map will still show coordinates and allow zooming, but without cached tiles it may appear blank until some are loaded. In any case, the location markers for rides will still display.
After these steps, you should have the app running. You can then proceed to use it as described below.

Usage
The application flows and usage differ for Users (Passengers) and Riders. Below is an overview of how each role interacts with the app:
For Users (Clients/Passengers)
Role Selection: When you launch the app, choose the User role. This will take you to the main interface for passengers.
Main Chat Screen: The user’s main screen is a chat interface where you can communicate with available riders via SMS. Initially, you may not have any rider selected. If you have previously interacted with a rider, the conversation will be listed here. You can tap on a past rider contact or message thread to focus on that rider for new messages. If no contacts are shown, you will need to initiate a chat or ride request with a known rider’s phone number. (Future enhancements may include discovering nearby riders automatically via cell location grouping.)
Requesting a Ride: To request a ride, you can simply send an SMS message to a rider through the chat (for example, "Hi, I need a ride from Location X to Y"). The app provides a "Request Ride" button as well – tapping this will open a Ride Request form. In the current implementation, the form allows you to confirm the rider’s phone number (ensuring you are messaging the correct person) and then proceed. When the request is sent, it is transmitted as an SMS to the rider’s phone. The rider will see this as an incoming ride request in their app (and as a text message on their device).
Sharing Location: You can send your location to the rider by tapping the "Share Location" button (for example, if you want to let the rider know exactly where you are). The app will fetch your approximate coordinates using the phone’s last known cell location or GPS (if available) without needing internet. It then formats this info (latitude/longitude, accuracy, etc.) into a short message and sends it via SMS to the rider. On the rider’s side, this may appear as a map link or coordinates that they can view on their map. This feature is useful for precise pickup coordination.
Viewing Map: If you want to see your location or past ride locations, you can tap the "Map" or "Preview Map" button. This opens the offline map viewer (powered by OSMDroid). Here you can see markers for locations that have been logged (e.g., each time you shared a location or a ride was completed). The map allows pinch-zoom and pan. Even if you are offline, previously cached map tiles will be shown. The map view is read-only for now (no live navigation), but it gives a visual overview of rides and locations.
Back to Chat: From the map or request screens, you can always navigate back to the chat interface to continue communicating with the rider. The chat history will update with any new messages (SMS) sent or received. Remember that all messages are actually being sent over the cellular network as SMS texts, so standard SMS fees or limitations might apply depending on your carrier.
For Riders (Drivers)
Role Selection: Choose the Rider role on the launch screen to enter the rider mode. This opens the rider dashboard, which is designed for motorcycle taxi drivers receiving requests.
Availability Status: At the top of the rider interface, you can toggle your status between "Available" and "Busy". When set to Available (green indicator), it indicates you are ready to receive ride requests. Toggling to Busy (red indicator) might be used to pause new requests (though users can technically still send SMS, this status is more for the rider’s reference and future expansion like filtering).
Incoming Ride Requests: The rider’s screen has a section for ride requests. By default, the app shows the Chat Messages view (SMS conversations with clients). There is a button "View Requests" which will switch the view to show a list of incoming ride requests. Each request in the list might show a brief description (e.g., the pickup location or request time) and the sender’s phone number. These requests are populated when a user sends a special ride request message or their location. The rider can click on a request item (in the current version, the list shown is a static placeholder for demonstration). In a fully implemented scenario, tapping a request could open details (perhaps using the same RequestRideActivity screen to view client information and location, and provide a way to respond).
Chat and Response: The rider can switch back to the Chat Messages view to see SMS conversations. All messages from users are listed here, along with the rider’s own replies. The interface is similar to a messaging app: it uses a RecyclerView to list chats. The rider can type a reply in the input field and hit Send. The app will then send that message as an SMS to the user (and also log it in the local database so it appears in the chat history). This allows the rider to communicate with the client to confirm details like pickup point, fare, etc. For example, after receiving a ride request, the rider might reply "I’m on my way, will reach in 5 minutes."
Sharing Rider’s Location: If needed, the rider can also share their own location with the user. When viewing a specific request or chat, a rider can use the "Share Location" feature (accessible in the ride request detail screen). This works similarly to the user’s share location – it fetches the rider’s current approximate location via cell towers/GPS and sends it as an SMS to the user. This can be helpful if the rider wants to let the user know where they currently are or to coordinate meeting in a busy area.
Ride History & Map: The rider’s app also logs location data and messages. A rider can open the Map Viewer to see a visual log of locations (for example, where they have picked up or dropped off clients). All recorded locations (from either party sharing location) can be displayed as pins on the map. This helps the rider recall previous rides or understand the general areas of service. The map is available offline so the rider can use it even in remote areas.
General Workflow: In practice, a typical offline ride-hailing interaction using this app might go as follows: A user opens the app, selects User mode, and chooses a rider (perhaps they know a local rider’s number or from a previous list). They send an SMS through the app to request a ride, optionally sharing their location. The rider (on their device with the app in Rider mode) receives an SMS notification of the request; the app logs it and shows a new request in the list. The rider replies via the app to confirm and heads towards the user. Both user and rider can open the map to see the shared location markers for clarity. Once the ride is fulfilled, they can continue to use the chat for any follow-up or simply end the session. All these communications happened via SMS but are presented in a user-friendly app interface.
Architecture Overview
This project follows a clean and modular architecture, primarily using the MVVM (Model-View-ViewModel) design pattern along with repository abstraction. Here’s an overview of how the code is structured:
Presentation Layer (UI): Activities and Views make up the UI for both rider and user features. For example, MainFunctionActivity handles the user chat interface, RiderActivity handles the rider dashboard, RequestRideActivity for the ride request form, MapViewerActivity for the map screen, etc. These Activities are kept lean by delegating data handling to ViewModels. The UI uses Android Jetpack ViewModel and LiveData to observe data changes (like new messages or location updates) and update the interface reactively. The layout files (XML) utilize Android Material Components for a modern look (buttons, text fields, etc.).
ViewModel Layer: Each important UI screen has a corresponding ViewModel (e.g., MainFunctionViewModel, RiderViewModel, MapViewerViewModel, etc.) that contains the core logic. The ViewModel interacts with the repository or helper classes to perform actions such as sending an SMS, fetching the latest messages from the database, retrieving the current offline location, or inserting new location logs. The ViewModels expose LiveData or other observable data to the UI, so when a new SMS arrives (and is saved to the DB via the receiver), the UI list updates automatically. Using ViewModels ensures that logic is not tightly coupled to Activities, and it survives configuration changes (like screen rotations).
Domain & Repository Layer: The app defines repository interfaces in the domain (for example, MessageRepository and LocationLogRepository) and provides implementations for them (e.g., MessageRepositoryImpl, LocationLogRepositoryImpl) that use local data sources. These repositories abstract away whether data is coming from a database, an SMS, or any other source. ViewModels call repository methods (e.g., to get all chat messages, or save a new message) without needing to know the details of data storage. This project’s domain logic is relatively simple (since most operations are direct local interactions), but having a repository pattern in place makes it easier to evolve. For instance, if in the future one wants to integrate a remote server or expand functionality, the ViewModel would still talk to the repository, and the repository could handle syncing between local and remote data.
Data Layer: The data layer consists of the local database and other system integrations:
Room Database: The app uses Room (an SQLite wrapper) for storing persistent data. There are entities such as MessageEntity (to store SMS chat messages with fields like sender, message content, timestamp) and LocationLogEntity (to store location points with latitude, longitude, accuracy, etc.). DAOs are defined to query these (for example, get all messages, insert a new message, get all location logs). The GeoQuizDatabase is the Room database that brings these entities and DAOs together. It’s a singleton provided via Hilt (so all parts of the app use the same database instance).
SMS & Telephony Integration: Sending and receiving SMS is done using Android’s telephony API. There is a BroadcastReceiver (SmsReceiver) that listens for incoming SMS (registered for the SMS_RECEIVED action). When an SMS arrives, the receiver parses the message and, if it’s relevant (e.g., from a known rider or containing a location payload), it will save it to the database and possibly trigger a notification or update to the UI via LiveData. For sending SMS, utility classes (e.g., OfflineSmsHelper) wrap around SmsManager to send text messages from within the app. These utilities format special messages, such as embedding location coordinates in a standardized format so that the receiver app can identify a "location share" versus a normal text.
Location Services: Instead of the full Google location services, the app uses a custom OfflineLocationHelper (and CustomLocationManager) to get the device’s location without requiring internet. This likely uses TelephonyManager or Android’s CellInfo APIs to get the cell tower info and approximate latitude/longitude (or uses the last known coarse location). It might also use GPS if available but works with coarse location when offline. The obtained location (with an accuracy radius) is then used within the app (e.g., saved to the log and sent to the other party via SMS). The accuracy is lower than GPS, but sufficient for giving a general area.
OSMDroid Map Integration: The map component is handled by OSMDroid. The map view in MapViewerActivity is configured with TileSourceFactory.MAPNIK (OpenStreetMap tiles) and set to offline mode. The code sets a user agent and can display markers. Markers are added for each saved LocationLog (with info like timestamp, accuracy, signal strength in the marker popup). The map can operate offline by using cached tiles. This integration is encapsulated such that the rest of the app only deals with location data, and the OSMDroid-specific logic is in the map Activity/VM.
Dependency Injection (Hilt): Dagger Hilt is used to glue the layers together. In the AppModule (annotated with @Module and @InstallIn(SingletonComponent.class)), we provide singletons like the GeoQuizDatabase, MessageRepositoryImpl, LocationLogRepositoryImpl, and our CustomLocationManager. These are injected wherever needed (e.g., in ViewModels or other classes) using @Inject. The application class GeoQuizApp is likely annotated with @HiltAndroidApp to initiate injection. Hilt helps eliminate a lot of boilerplate in managing instances and allows the app to scale - for example, if tomorrow we add a new repository or service, we can easily provide it via Hilt and inject into the necessary classes without tightly coupling creation logic. This also makes testing easier, as we can provide fake implementations of repositories when running unit tests.
Overall, the architecture is designed to separate concerns: UI deals with presenting data and taking input, ViewModels handle coordination and business logic, repositories manage data operations, and system services (SMS, location, database) are abstracted so they can be used interchangeably or modified with minimal changes to higher layers. This modular approach means each piece (SMS handling, location, UI, data storage) can be worked on independently. It also follows best practices for Android development, making the app more robust and maintainable.
Technologies Used
The project utilizes a range of technologies and libraries to achieve its functionality:
Programming Language: Java (Android). The codebase is primarily in Java, using Android SDK and Google’s libraries. (It could be extended with Kotlin if needed, but the current implementation is Java-based.)
Android SDK & Jetpack: Core Android components (Activities, Intents, BroadcastReceiver, etc.) and Jetpack libraries like LiveData, ViewModel, and Room are used. The project uses AndroidX libraries throughout (e.g., androidx.appcompat for compatibility support, AndroidX RecyclerView for list UI).
SMS and Telephony: Android Telephony API (SmsManager, TelephonyManager) for sending and receiving SMS messages. The app requires the SEND_SMS, RECEIVE_SMS, and READ_SMS permissions. It uses a broadcast receiver to handle incoming texts and the SmsManager to send outgoing texts programmatically.
Location Services: Android Location and Telephony services for coarse location. By using cell tower information (and optionally GPS if available), the app gets location without needing network data. This might involve android.location.LocationManager with NETWORK_PROVIDER or telephony cell info for offline approximation.
OSMDroid Library: OSMDroid is an open-source Android library for displaying OpenStreetMap data. This project includes OSMDroid to provide map views that work offline. OSMDroid handles map tiles, zooming, panning, and overlaying markers. It’s a lightweight alternative to Google Maps for offline scenarios, as it can cache map tiles and doesn’t require an API key.
Room Database: Part of Android Jetpack, Room provides an ORM-ish layer over SQLite. It is used for storing chat messages (MessageEntity) and location logs (LocationLogEntity). Room ensures easy database access with compile-time checks for SQL queries and allows the use of LiveData to observe changes in data.
Dagger Hilt (Dependency Injection): Hilt is the DI framework used to manage dependencies. It simplifies the use of Dagger in Android apps. We use Hilt annotations (@HiltAndroidApp, @AndroidEntryPoint, @HiltViewModel, @Module, @Provides) to inject singletons like the database and repositories into Activities and ViewModels. This removes the need for manual dependency instantiation and helps with testing and modularity.
Material Design UI: The app uses Google’s Material Design components (via the Material Components library) for a modern UI feel. Buttons, text inputs, toggles, etc., follow material styling as defined in the app theme (Theme.GeoQuiz in styles). This ensures the UI is familiar and user-friendly.
Architecture Components: Aside from Room and ViewModel (already mentioned), we use RecyclerView with custom Adapter classes (like RiderHistoryAdapter) to display lists of messages and requests. Also utilized are lifecycle-aware components that keep the app efficient and responsive (for example, observing LiveData only when the Activity is in foreground).
These technologies work in unison to provide an application that is functional offline, yet structured in a modern way. For instance, OSMDroid plus offline location logic enables mapping without internet, Hilt + MVVM ensures the code is clean, and SMS integration provides the core communication channel.
Contributing Guidelines
Contributions to the project are welcome! If you have ideas for improvements or new features (for example, better UI, automated rider discovery, integration with an SMS gateway, etc.), feel free to contribute. Please follow these guidelines when contributing:
Fork the Repository: Start by forking the repository to your own GitHub account. This will allow you to make changes in isolation.
Create a Branch: Create a new branch for your feature or bugfix. Use a descriptive branch name (e.g., feature/improved-location-accuracy or bugfix/sms-crash-fix).
Make Changes: Implement your feature or fix in your branch. Ensure that the code follows the existing style and structure of the project. If you introduce new dependencies or significant refactoring, update the documentation (or README) accordingly.
Test Thoroughly: Before submitting, test the app with your changes. Because this app deals with SMS and offline scenarios, try to simulate those conditions (you can use two emulators to send SMS back and forth, or an actual device if possible). Make sure existing functionality is not broken by your changes.
Commit & Push: Commit your changes with clear commit messages explaining what and why you changed. Push the branch to your fork on GitHub.
Open a Pull Request: Go to the original repository and open a PR from your fork’s branch. In the pull request description, detail the changes you’ve made and why they would benefit the project. If the PR addresses an open issue, reference that issue number.
Code Review: Maintainers or other contributors will review your PR. Please be open to feedback and be prepared to make adjustments if requested. Discussion is part of the process to maintain code quality.
Merge: Once approved, your changes will be merged into the main repository. You can then delete your branch. Congratulations on your contribution!
By contributing to this project, you agree that your contributions will be licensed under the same license as the project (see the License section below). Also, ensure you only contribute original code or code you have rights to share, as this project is open-source. If you encounter any issues or have questions, you can open an issue on GitHub. We appreciate bug reports, feature suggestions, and general feedback. Together, we can improve this application to better serve communities with limited internet access.
License
This project is licensed under the MIT License. You are free to use, modify, and distribute this software as per the terms of the license.
swift
Copy
MIT License

Copyright (c) 2025 Deline Kipchirchir (Dzeline)

Permission is hereby granted, free of charge, to any person obtaining a copy...
(The full license text is available in the LICENSE file of the repository.) By using or contributing to SMS Based Boda-Ride Service Application, you agree to the terms and conditions of this license. This basically means you can use the code for your own purposes (even commercial) but you must include the copyright notice and cannot hold the authors liable for any issues. For detailed information, please refer to the complete MIT License text.
Thank you for checking out the SMS Based Boda-Ride Service Application! We hope this project can help improve transportation access in low-connectivity areas. If you have any questions or need help running the app, please feel free to reach out or open an issue.
